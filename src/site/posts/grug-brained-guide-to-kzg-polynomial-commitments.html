<html>
    <head>
        <link rel="stylesheet" type="text/css" href="../site.css">
        <title> Grug Brained Guide to KZG Polynomial Commitments</title>
    </head>
    <body>
        <header>
            <nav>
                <a href="/about.html">about</a>
                <a href="/">posts</a>
            </nav>      
        </header>
        <main>
        <h1> Grug Brained Guide to KZG Polynomial Commitments</h1>
        <p>In this post, I&rsquo;m aiming to explain to myself what a KZG polynomial commitment is,
and talk about my <a href="https://github.com/bingcicle/kzigg" target="_blank">Zig implementation</a>.
If you&rsquo;re only curious about the Zig usage, feel free to skip to the last section.</p>

<h1 id="why-another-explainer">Why another explainer?</h1>

<p>Most blog posts/explainers I found out there start off with the heavy math or
the deep technical components of what a KZG polynomial commitment is
right away. They also are often disconnected, going from one concept to the
next without making it very clear how it all links together. The real kicker
imo is that none really starts off with the motivation behind KZG in the
context of Ethereum and a brief technical overview first.
The closest I found was <a href="https://twitter.com/protolambda" target="_blank">@protolambda</a>&rsquo;s
<a href="https://hackmd.io/@protolambda/eip-4844-implementer-notes" target="_blank">implementor notes</a>.</p>

<p>So this post is more of a post to myself prior to learning about KZG, and is
meant to be a bridge to the more
<a href="https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html" target="_blank">technical</a>
<a href="https://alinush.github.io/2020/05/06/kzg-polynomial-commitments.html" target="_blank">and</a>
<a href="https://www.zkdocs.com/docs/zkdocs/commitments/kzg_polynomial_commitment/" target="_blank">instructional</a>
<a href="https://scroll.io/blog/kzg" target="_blank">articles</a> (each word here is a link!) that
already exists out there.</p>

<p>This post might be helpful if you think like me and require some motivating examples
and a high level overview first to put the technical knowledge into practice.
Otherwise, more technical readers should probably read the above links instead.</p>

<h1 id="why-kzg-commitments">Why KZG commitments?</h1>

<p>Before we understand what a KZG commitment is, I&rsquo;d like to think that
we should understand what they&rsquo;re used for first.</p>

<p>For a long while, Ethereum transaction fees have been way too expensive
for regular users. Every transaction you made had to be processed by
every participating validator in the network, and the fees that you pay is
the cost of processing those transactions.</p>

<p>Rollups were meant to solve this problem by bundling transactions together
but even rollup fees can get too expensive for many users since rollups
still need to pay for the data posted onto mainnet,
and this posting of data is a function of how large the data
blobs are and the current L1 gas price.</p>

<p>Knowing the above, the solution is probably to</p>

<ol>
<li>either post less data or not post the data at all, and/or</li>
<li>have some sort of gas-agnostic way to post the data</li>
</ol>

<p>The long term solution is to shard data which takes time to implement,
so a stopgap solution is necessary to make fees cheaper for now. This stopgap
is <a href="https://eips.ethereum.org/EIPS/eip-4844" target="_blank">EIP-4844</a>.
The crux of it is to introduce the <em>transaction format</em> that
will be used in sharding but not actually shard those transactions. This
(kinda) addresses the 2 problems above.
Notably, point 1 is where <strong>KZG commitments</strong> come in.</p>

<p><strong>&ldquo;<em>either post less data or not post the data at all</em>&rdquo;</strong></p>

<p>Currently, transaction data is stored within the calldata, which is visible
to the EVM and is a permanent part of the blockchain. EIP-4844 introduces
blob-carrying transactions which makes Ethereum store data on the
consensus layer rather than the execution layer (EVM). Rather, what the
execution layer sees is the <em>commitment</em> to those blobs. These commitments
are smaller in size which saves on gas, and it is sufficient to verify
these commitments without needing to access the actual blobs.</p>

<p><strong>&ldquo;<em>have some sort of gas-agnostic way to post the data</em>&rdquo;</strong></p>

<p>So 4844 solves this by introducing an entirely separate fee market for blobs
(which is why I said <em>kinda</em> above). I&rsquo;m not clued in on the details here yet
so I can&rsquo;t confidently write here about what this means, and this is probably
out of scope for this blog post anyway!</p>

<h1 id="kzg-commitments">KZG commitments</h1>

<p>Now we can get to how we achieve point 1 mentioned above. Commitment schemes
allow one to publish a value which binds one to a message without revealing it.
One can then open the commitment and reveal the committed message to a verifier
to be checked. Of course this only makes sense if the cost of committing is
less than the cost of sending the entire message.</p>

<p><a href="https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf" target="_blank">KZG (Kate-Zaverucha-Goldberg) commitments</a>
are a class of the above scheme.</p>

<p>Some key characteristics that is useful for 4844:</p>

<ul>
<li>Constant size commitment/proof (48 bytes). This is especially useful for batching,
since the proof size is always constant regardless of the size of the blob.</li>
<li>Verification is a single pairing check (constant time)</li>
</ul>

<h1 id="how-it-works-eli5">How it works, ELI5</h1>

<p>The scheme itself is stupidly simple from an engineering POV and I didn&rsquo;t realize
this myself prior to implementing it (The math is super complicated though).
@protolambda explained it best in the notes linked at the top: you only need</p>

<ol>
<li>a linear combination to compute a KZG commitment,</li>
<li>a single pairing verification to verify a KZG proof</li>
</ol>

<p>Obviously there are way more details behind how the above steps happen
(serialization/deserialization of blobs, how pairings work, optimizations, etc.),
but the above 2 steps is really all that is happening in the scheme.</p>

<p>Again, I would highly recommend the other articles for the math but nevertheless
I will give a short overview here.</p>

<h2 id="setup">Setup</h2>

<p>Some commitment schemes use some secret value within its computation, and this
secret value is often obtained via something called a
<a href="https://ceremony.ethereum.org" target="_blank"><strong>trusted setup</strong></a>.
Essentially this is a multiparty procedure where each party creates some secret
and runs a computation to mix it with the previous contributions.
Eventually, the final secret value will be used for the commitment scheme.
The cool thing about this trusted setup is that it has a
&ldquo;1-of-N&rdquo; trust assumption, which means only a single participant is required
to be honest for the procedure to be secure.</p>

<h2 id="commit">Commit</h2>

<p>As mentioned earlier, a commitment is simply a linear combination. A blob of bytes
has its data transformed into a polynomial and then a linear combination done
on its points, producing a serialized G1 point (48 bytes in size) which serves
as the commitment. This can be done naively (very slow) or via Pippenger&rsquo;s algorithm.</p>

<h2 id="prove">Prove</h2>

<p>Now we want to show that we know the original data in the blob, otherwise the
polynomial. The simplest way to do that is if the prover sends the entire polynomial
to the verifier, but that would defeat the point of the commitment scheme.
Instead, the verifier sends over a <strong>challenge</strong>, which the prover will evaluate
the polynomial with to produce the <strong>evaluation</strong> and an <strong>evaluation proof</strong> that
attests to the fact that the polynomial was correctly evaluated.</p>

<h2 id="verification">Verification</h2>

<p>Verification is then done with a <a href="https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627" target="_blank">pairing</a>
check, which I treated as a black box for this post and implementation
because I don&rsquo;t know enough to make sensible comments. Instead, I&rsquo;ve linked to
Vitalik&rsquo;s blog post on the topic. Point is, if the
pairings check passes, then very highly likely our evaluation proof was correct.</p>

<h2 id="batching">Batching</h2>

<p>These blobs, commitments and proofs can be batch verified thanks to the
homomorphic property of KZG. AFAIK this entails some re-engineering around
how transactions are processed, which (once again) @protolambda explains in the
link at the top.</p>

<h1 id="zig-implementation">Zig implementation</h1>

<p>I ported <a href="https://github.com/ethereum/c-kzg-4844" target="_blank">c-kzg-4844</a> to Zig
just to learn what goes behind the scheme. I wrote
previously about <a href="https://bingcicle.github.io/posts/ziggifying-kilo.html" target="_blank">porting another C project</a>
to Zig so for general impressions you can check that post out.
I&rsquo;ll post thoughts specifically comparing my implementation with the C version.</p>

<h2 id="c-interop">C Interop</h2>

<p>For the Zig implementation, like the C version, I relied on <a href="https://github.com/supranational/blst" target="_blank"><code>blst</code></a>
for the backend, which means I had a chance to finally try C interop
after using Zig for some time. Zig natively supports
<a href="https://ziglearn.org/chapter-4/" target="_blank">C ABIs</a>, making it possible for new programs
to be built leveraging C libraries.</p>

<p>Frankly, it surprised me with how easy it was to just build <code>blst</code> and use it as a
static library in Zig. Zig pointers also coerce nicely to C pointers, which was
super convenient to not have to do weird casts when calling <code>blst</code>.</p>

<p>Why bother with C? Well, when a C library is audited and battle-tested, it
may be better to just use it rather than reinvent the wheel, which is exactly
what Zig enables you to do easily.</p>

<h2 id="defer-is-great">Defer is great</h2>

<p>In the C implementation, there&rsquo;s heavy abuse of <code>goto</code>s in order to free data
whenever some computation finishes or when errors occur. This is where C
gets a bad rap, because the need to do manual memory management along with
copious amounts of indirection leads to bug-prone code.</p>

<p>Instead of doing all that, Zig encourages the <code>alloc-defer</code> pair pattern:</p>

<pre><code class="language-zig">    const allocator = std.testing.allocator;
    // This allocates
    const cfg = try KZGTrustedSetupConfig.loadFromFile(
        allocator,
        &quot;./src/trusted_setup.txt&quot;,
    );
    // This frees when out of scope
    defer cfg.deinit();
</code></pre>

<p>This means less cognitive load on thinking about where and when to free your memory.</p>

<h2 id="general-cleanliness">General cleanliness</h2>

<p>Generally, the Zig version felt slightly cleaner to me and came out to about
~1100LOC (including tests). The <a href="https://github.com/ethereum/c-kzg-4844/blob/main/src/c_kzg_4844.c" target="_blank">c_kzg_4844.c</a>
file alone came to about 1.5x of that.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Hopefully this was a decent enough overview of the KZG commitment scheme&rsquo;s role in
4844 for the grug brained devs like me. Commitment schemes are magical protocols
that when applied in the right areas can save on space and work done.</p>

        </main>
    </body>
</html>
<html>
